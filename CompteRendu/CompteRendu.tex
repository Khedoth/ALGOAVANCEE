\documentclass[a4paper, titlepage]{article}

\usepackage[utf8]{inputenc} % accents
\usepackage[T1]{fontenc}      % caractères français
\usepackage[margin=1in]{geometry}         % marges
\usepackage[francais]{babel}  % langue
\usepackage{graphicx,subfigure}         % images
\usepackage{verbatim}         % texte préformaté
\usepackage{float}

\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{lastpage}

\renewcommand\headrulewidth{1pt}
\fancyhead[L]{Algorithmique avancée}
\fancyhead[R]{ENSSAT}

\renewcommand\footrulewidth{1pt}
\fancyfoot[C]{\today}
\fancyfoot[L]{VYTHELINGUM - NOKAYA}
\fancyfoot[R]{\textbf{Page \thepage/\pageref{LastPage}}}

\title{Mini-projet d'algorithmique avancée}      % renseigne le titre
\author{Kévin VYTHELINGUM, Jean-Michel NOKAYA}           %   "   "   l'auteur
\date{\today}           %   "   "   la future date de parution



\begin{document}
\maketitle
\tableofcontents
\newpage
\large

\section{Introduction}

\section{Préliminaires}

\begin{enumerate}
\item
	\begin{eqnarray*}
	d_{max} & \Rightarrow & c_{min} \\
	\sum_{i=1}^{k} d_{max} & \Rightarrow & \sum_{i=1}^{n} c_{min} \\
	D & \Rightarrow & C_{opt}
	\end{eqnarray*}
\item
	complexité = $k^{n}$ (On peut faire un arbre pour le démontrer)

\end{enumerate}

\section{Méthodes des essais successifs}

	\subsection{Analyse}

		\paragraph{} \noindent
		Solution : un candidat est un vecteur de taille n où chaque coefficient est une durée choisie parmi l'ensemble \{1,...,k\} (à chaque tâche on associe une durée).
		On choisit d'enregistrer les choix réalisés dans un tableau T de taille n.

		\paragraph{}\noindent
		$S_{i}$ : l'ensemble des durées possibles de 1 à k

		\paragraph{}\noindent
		$satisfaisant(x_{i}) = \sum_{j=1}^{i} x_{j} \le D$

		(la somme partielle des durées choisies est inférieure à la durée maximale autorisée)

		\paragraph{}\noindent
		$enregistrer(x_{i}) = T[i] \leftarrow x_{i}$

		\paragraph{}\noindent
		\emph{soltrouvee} : $i = n$

		\paragraph{}\noindent
		$defaire(x_{i}) = T[i] \leftarrow 0$

		\paragraph{}
		Pour simplifier les vérifications au niveau de satisfaisant et des conditions d'élagage, on utilisera les variables entières \emph{cout} et \emph{duree} initialisée à 0,
		qui représenteront le cout courant et la durée courante duent à nos choix de durées.
		Elles seront mises à jour dans \emph{enregistrer} et dans \emph{défaire}.
		En effet, en notant \emph{CD} le tableau à deux dimensions ayant les coûts en ligne et les durées en colonne, on effectura dans \emph{enregistrer} :

			\begin{eqnarray*}
				\mbox{coût}  & \leftarrow & \mbox{coût} + CD[i][x_{i}] \\
				\mbox{durée} & \leftarrow & \mbox{durée} + x_{i}
			\end{eqnarray*}

		Ensuite on effectura dans \emph{défaire} :

			\begin{eqnarray*}
				\mbox{coût}  & \leftarrow & \mbox{coût} - CD[i][x_{i}] \\
				\mbox{durée} & \leftarrow & \mbox{durée} - x_{i}
			\end{eqnarray*}

	\subsection{Condition d'élagage}


	\subsection{Algorithme}

		\subsubsection{Sans élagage}

			Cet algorithme repose sur le modèle de programmation de recherche d'une solution optimale par essais successifs.
			Le principe est d'essayer toutes les combinaisons possibles tant qu'elles sont satisfaisantes, c'est-à-dire dans notre cas que la somme partielle des durées choisies est inférieure à la durée maximale autorisée D.
			Pour obtenir la solution optimale, on vérifie que le coût d'une solution obtenue est strictement inférieur au coût de la meilleure solution trouvée, auquel cas on l'affiche.
			La dernière solution affichée sera donc la solution optimale.

			L'appel de l'algorithme consiste à initialiser le coût optimal au coût maximal qu'il est possible d'obtenir, puis à appeler la procédure au rang 1, c'est-à-dire commencer par choisir la durée de la première tâche $T_{1}$.

			\begin{tabbing}

			\hspace{1cm}\=\hspace{1cm}\=\hspace{1cm}\=\hspace{1cm}\=\hspace{1cm}\=\kill % défini la longueur d'une tabulation

			\textbf{procédure} $ordonnancement\_simple$ (ent i); \\
			\textbf{var} ent n, k, $x_{i}$, D; \\
			\textbf{var} ent cout, duree; \\
			\textbf{début} \\
			\> $cout \leftarrow 0;$ \\
			\> $duree \leftarrow 0;$ \\
			\> \textbf{pour} $x_{i}$ \textbf{de} 1 \textbf{à} k \textbf{faire} \\
			\>\> \textbf{si} $duree\le D$ \textbf{alors} \\
			\>\>\> $T[i] \leftarrow x_{i};$ \\
			\>\>\> $cout \leftarrow cout + cd[i][x_{i}];$ \\
			\>\>\> $duree \leftarrow duree + x_{i};$ \\

			\>\>\> \textbf{si} i = n \textbf{alors} \\
			\>\>\>\> \textbf{si} $cout < cout\_opt$ \textbf{alors} \\
			\>\>\>\>\> $affiche(T)$; \\
			\>\>\>\> \textbf{fsi}; \\

			\>\>\> \textbf{sinon} \\
			\>\>\>\> $ordonnancement\_simple(i+1)$; \\
			\>\>\> \textbf{fsi}; \\

			\>\>\> $T[i] \leftarrow 0;$ \\
			\>\>\> $cout \leftarrow cout - cd[i][x_{i}];$ \\
			\>\>\> $duree \leftarrow duree - x_{i};	$ \\
			\>\> \textbf{fsi}; \\
			\> \textbf{fait}; \\
			\textbf{fin};

			\end{tabbing}

			\noindent
			Appel : $cout\_opt \leftarrow c_{max};$ $ordonnancement\_simple(1)$;

		\subsubsection{Avec élagage}

	\subsection{Complexité temporelle}

	\subsection{Expérimentations}

\section{Programmation dynamique}

	\subsection{Formule de récurrence}
	\subsection{Structure tabulaire}
	\subsection{Algorithme}
	\subsection{Complexité temporelle}
	\subsection{Complexité spatiale}

\section{Question complémentaires}
\begin{enumerate}
\item
\item
\item
\item
\item
\end{enumerate}

\section{Conclusion}


\end{document}
